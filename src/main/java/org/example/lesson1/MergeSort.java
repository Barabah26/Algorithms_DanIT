package org.example.lesson1;

import java.util.ArrayList;
import java.util.List;

public class MergeSort {
    public static void main(String[] args) {
        // Створюємо список чисел, який будемо сортувати
        List<Integer> collection = new ArrayList<>(List.of(1, 5, 100, 32, 5, -2));
        System.out.println("Before sorting: " + collection);

        // Викликаємо метод сортування
        sort(collection);

        // Виводимо відсортований список
        System.out.println("After sorting: " + collection);
    }

    // Метод сортування
    private static void sort(List<Integer> list){
        // Перевіряємо, чи список порожній або містить лише один елемент
        if (list.isEmpty() || list.size() == 0)
            return;

        // Створюємо тимчасовий список для зберігання проміжних результатів сортування
        List<Integer> temp = new ArrayList<>(list);

        // Викликаємо рекурсивний метод сортування
        mergeSort(list, temp, 0, list.size() - 1);
    }

    /**
     Цей метод реалізує алгоритм рекурсивного сортування злиттям.
     Вхідні параметри list, temp, left та right вказують на список для сортування, тимчасовий список, ліву та праву межі діапазону, який ми хочемо відсортувати.
     Метод перевіряє, чи діапазон для сортування є валідним (тобто, чи left менше right). Якщо це не так, то це означає, що в діапазоні є лише один елемент або діапазон порожній, тому сортування не потрібно і метод завершує свою роботу.
     В іншому випадку, метод розбиває діапазон на дві частини, обчислюючи середину middle, і викликає себе рекурсивно для кожної з половин.
     Нарешті, викликається метод merge, який зливає відсортовані половини діапазону.
     */
    // Рекурсивний метод сортування злиттям
    private static void mergeSort(List<Integer> list, List<Integer> temp, int left, int right) {
        // Перевіряємо, чи діапазон для сортування валідний
        if (left < right){
            // Знаходимо середину діапазону
            int middle = (left + right) / 2;

            // Рекурсивно сортуємо ліву половину
            mergeSort(list, temp, left, middle);

            // Рекурсивно сортуємо праву половину
            mergeSort(list, temp, middle + 1, right);

            // Зливаємо відсортовані половини
            merge(list, temp, left, middle, right);
        }
    }

    /**
     Цей метод виконує злиття двох відсортованих підсписків.
     Вхідні параметри list, temp, left, middle та right вказують на список, тимчасовий список, ліву, середню та праву межі діапазону, який ми хочемо злити.
     Спочатку копіюються елементи з вихідного списку list у тимчасовий список temp для подальшого порівняння та злиття.
     Потім виконується злиття двох підсписків, індекси яких вказуються змінними i та j, у вихідний список list, індекс якого вказується змінною k.
     Поки індекси i та j не досягнуть кінця своїх підсписків, елементи порівнюються та додаються до вихідного списку у відповідному порядку.
     Нарешті, будь-які залишкові елементи з кожного підсписку, які можуть залишитися, копіюються у вихідний список.
     */

    // Метод для злиття двох відсортованих підсписків в один
    private static void merge(List<Integer> list, List<Integer> temp, int left, int middle, int right) {
        int i = left; // Індекс для першого підсписку
        int j = middle + 1; // Індекс для другого підсписку
        int k = left; // Індекс для результату злиття

        // Копіюємо елементи в тимчасовий список
        for (int l = left; l <= right; l++) {
            temp.set(l, list.get(l));
        }

        // Зливаємо два підсписки
        while (i <= middle && j <= right){
            if (temp.get(i) <= temp.get(j)){
                list.set(k, temp.get(i)); // Оновлюємо значення елементу в початковому списку
                i++;
            } else {
                list.set(k, temp.get(j)); // Оновлюємо значення елементу в початковому списку
                j++;
            }
            k++;
        }

        // Копіюємо залишки першого підсписку (якщо вони є)
        while (i <= middle) {
            list.set(k, temp.get(i)); // Оновлюємо значення елементу в початковому списку
            k++;
            i++;
        }
        // Копіюємо залишки другого підсписку (якщо вони є)
        while (j <= right) {
            list.set(k, temp.get(j)); // Оновлюємо значення елементу в початковому списку
            k++;
            j++;
        }
    }
}
